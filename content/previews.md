# Как организовать предпросмотр загружаемых изображений

Каждый раз, делая компонент загрузки изображений (аватарок, документов, картинок в чате) стоит задача показать превью до того как изображение будет загружено на сервер.
Самым первым и распространенным решением является использование FileReader API.

Не долго думая идем реализовывать:
```javascript
<input type="file" @onChange="handleChange" />
<div class="previews" />

function handleChange(event) {
  if (event.target.files) {
    event.target.files.forEach(previewFile);
  }
}

function previewFile(file) {
  const fileReader = new FileReader();

  fileReader.addEventListener('load', function () {
    const image = document.createElement('img');
    image.src = this.result;

    previews.appendChild(img);
  });

  fileReader.readAsDataURL(file);
}
```

Отлично! Код работает, можно идти дальше делать свои задачи.

Но что то нас тревожит. Код работает, задача выполнена, какие могут быть причины? Мы возвращаемся к части кода с отображением превью и начинаем разбираться что же здесь не так.

Для начала мы видим что чтение файла происходит асинхронно, а нам хотелось бы писать асинхронный код с промисами и `await`. Так же мы видим что чтение файла происходит в момент когда он попадает в браузер в виде `Blob` объекта, и после, когда мы уже сами конвертируем его в `dataURL`.

### Что же на самом деле происходит когда мы собираемся показать превью?

Для начала, input в обработчике события возвращает список объектов `File` которые наследуются от `Blob`. Единственным различием между ними является наличие у `File` полей `name` и `lastModified`.

Сам по себе `File` нам не очень полезен, потому что содержит в себе бинарное представление файла, которые мы не можем отобразить на странице. Класс `FileReader` содержит методы:
- `readAsArrayBuffer()` — возвращает `ArrayBuffer`
- `readAsBinaryString()` — возвращает сырые бинарные данные в виде строки
- `readAsText()` — читает файл как текст и возвращает строку с результатом;
- `readAsDataURL()` — читает содержимое файла и возвращает строку с base64 представлением файла вида `data:*/*;base64,`;

Нам подходит только `readAsDataURL()` так как мы можем подставить base64 строку в src аттрибут изображения и таким образом отобразить картинку на странице.

Ок, давайте разберем что же именно происходит во время работы `readAsDataURL()`:

1. Создается поток бинарных данных вызовом метода `stream()` у Blob объекта.
2. Созданному потоку назначается читатель и он блокирует поток.
3. Создается промис с результатом чтения потока.
4. Ожидается пока промис выполнится.
5. Если промис выполнен успешно и результатом является последовательность байт:
    1. Последовательность байт конвертируется в представление DataURL.
    2. Возвращается контейнер, содержащий последовательность байт, DataURL и тип Blob объекта.
7. Иначе выбрасывается исключение с причиной отклонения промиса.

В этом процессе нужно учесть что файл читается не целиком, а частями, где каждая итерация чтения длится примерно 50мс.

Два раза читать файл, а после конвертировать — это не эффективно, ведь у нас уже есть Blob, который мы можем отобразить на странице другим способом.

На помощь приходит `URL.createObjectURL()`. Он связывает файл в памяти с уникальной ссылкой на него. Таким образом у нас получается ссылка, которую мы можем подставить в src изображения:

```javascript
function previewFile(file) {
  const url = URL.createObjectURL(file);
  const image = document.createElement('img');
  image.src = url;

  previews.appendChild(img);

  return url;
}
```
Код получился гораздо короче и без асинхронных вызовов, однако важно учитывать что созданный url будет существовать в памяти до тех пор пока существует document и он будет ссылаться на файл, что приведет к большому расходу памяти. Поэтому нужно не забывать очищать ссылки когда они перестают быть нужны: `URL.revokeObjectURL(url)`.

Для сравнения с FileAPI, давайте посмотрим, сколько работы выполняется при создании ссылки на объект:

1. Создается пустая строка которая будет содержать ссылку.
2. В строку добавляется "blob:".
3. Из объекта настроек текущего контекста выполнения JavaScript получается origin.
4. Origin сериализуется в ASCII представление (Результатом сериализации origin вида `("https", "maraña.example", null, null)` будет `https://xn--maraa-rta.example`).
5. В результирующую строку добавляется сериализованный origin
6. В эту же строку добавляется `U+0024 SOLIDUS` (/)
7. Генерируется UUID и добавляется к результирующей строке

Получается строка вида `blob:https://xn--maraa-rta.example/9115d58c-bcda-ff47-86e5-083e9a2153041`.

Дальше в *blob URL store* юзер агента добавляется запись пары `url=Blob`, где url — сгенерированная строка и Blob — ссылка на файл в памяти.

Если сравнить два этих подхода, самая сложная операция во втором варианте — это генерация UUID, которая занимает гораздо меньше времени и ресурсов чем чтение файла и конвертация его в base64. Так же во втором варианте не нужно писать асинхронный код и он получается более читаемым.
