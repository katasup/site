# Введение в функциональное программирование

*Это перевод статьи [Mary Rose Cook](https://maryrosecook.com) опубликованной в [Code Words](https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming).*

Множество статей о функциональном программировании рассказывают об абстрактных функциональных техниках, таких как композиция, конвейеры, функции высшего порядка. Но не эта. Здесь я рассмотрю примеры императивного, не-функционального кода, какой люди пишут каждый день, и переведу их в функциональный стиль.

В первой части я возьму небольшой цикл, изменяющий данные и переведу его в функциональные map и reduce. Во второй части возьму цикл побольше, разобью его на атомарные единицы и сделаю каждую единицу функциональной. В третьей части будет длинная сериея последовательных преобразований данных и которую я декомпозирую в функциональный пайплайн.

## Ориентир в функциональном стиле
Когда люди говорят о функциональном программировании, они часто упоминают ошеломляющее количество "функциональных" характеристик, таких как неизменяемые данные<sup id="ref:1">[1](#note:1)</sup>, функции как объекты первого класса<sup id="ref:2">[2](#note:2)</sup> и хвостовые оптимизации<sup id="ref:3">[3](#note:3)</sup>. Они упоминают свертки, пайплайны, рекурсию, каррирование<sup id="ref:4">[4](#note:4)</sup> и использование функций высшего порядка. Все это методы программирования, используемые для написания кода в функциональном стиле. Еще они упоминают параллелизм<sup id="ref:5">[5](#note:5)</sup>, ленивые вычисления<sup id="ref:6">[6](#note:6)</sup> и детерминизм<sup id="ref:7">[7](#note:7)</sup>. Это полезные свойства функциональных программ.

Игнорируйте все это. Код в функциональном стиле имеет одну характеристику: отсутствие побочных эффектов. Он не полагается и не изменяет данные находящиеся за пределами текущей функции. Любое другое "функциональное" поведение может быть получено из этого свойства.

Это не функциональный код:
```javascript
let a = 0;

function increment() {
  a = a + 1;
}
```

Это функциональный код:
```javascript
function inrement(a) {
  return a + 1;
}
```

## Не итерируйте списки. Используйте map и reduce.
### Map
Map принимает функцию и коллекцию элементов. Он создает новую пустую коллекцию, применяет переданную функцию к каждому элементу исходной коллекции, вставляет получаемое значение в новую коллекцию и возвращает ее.

В JavaScript map — это метод, который поставляется в комплекте с каждым массивом, так что он может быть вызван непосредственно на массиве, данные которого вы собираетесь преобразовывать. В некоторых других языках, как, например, Python, map — это глобальная функция, которая не имеет привязки к коллекции, и ее можно вызывать передав в качестве параметра коллекцию любого типа.

Вот пример как map принимает список имен и возвращает список с длинной каждого имени:
```javascript
function len(string) {
  return string.length();
}

console.log(['Mary', 'Isla', 'Sam'].map(len));
// [4, 4, 3]
```

А это map, возводящий в квадрат каждое число переданной коллекции:
```javascript
console.log([0, 1, 2, 3, 4].map(x => x * x));
// [0, 1, 4, 9, 16]
```

Здесь я не предаю именованную функцию, вместо этого создается анонимнуя функция на месте — лямбда. Параметры лямбды и тело разделяются символом `=>`. Результатом выполенения является результат выражения в теле, поэтому нет необхожимости явно указывать что функция возвращает.

Нефункциональный код ниже берет лист реальных имен и заменяет их случайно определенными кодовыми именами.

```javascript
const names = ['Mary', 'Isla', 'Sam'];
const codeNames = ['Mr. Pink', 'Mr. Orange', 'Mr. Blonde'];

for (let i = 0; i < names.length; i++) {
  const randomIndex = Math.random() * codeNames.length;
  names[i] = codeNames[randomIndex];
}
```

*Как можно увидеть, этот алгоритм может потенциально назначить одно и то же секретное кодовое имя нескольким агентам. Надеюсь, это не будет источником путаницы во время секретной миссии.*

Его можно переписать в функциональном стиле:
```javascript
const names = ['Mary', 'Isla', 'Sam'];
const codeNames = ['Mr. Pink', 'Mr. Orange', 'Mr. Blonde'];

const randomChoice = arr => arr[Math.random() * arr.length];

const secretNames = names.map(() => randomChoice(codeNames));
```

**Упражнение 1.** Попробуйте переписать пример ниже в функциональном стиле с использованием map. Здесь список реальных имен заменяется настоящими шифрами, для полной секретности.

```javascript
const names = ['Mary', 'Isla', 'Sam'];

for (let i = 0; i < names.length; i++) {
  names[i] = btoa(names[i]);
}

// ["TWFyeQ==", "SXNsYQ==", "U2Ft"]
```

*Надеюсь, у секретных агентов хорошая память и они не забудут секретные имена друг друга во время секретной миссии.*

### Reduce (свертка)
Reduce принимает функцию, коллекцию элементов и, опционально, начальное значение аккумулятора. Он возвращает значение, полученное после комбинации всех элементов.

Это простой пример как reduce возвращает сумму всех элементов коллекции.
```javascript
[0, 1, 2, 3, 4].reduce((acc, num) => acc + num, 0);
// 10
```

`num` — это текущий элемент массива, `acc` — аккумулятор. Аккумулятор — это значение, которое вернула лямбда для предыдущего элемента. Reduce проходит по всем элементам, выполняет лямбду на каждом `num` и `acc` и возвращает результат в качестве `acc`  для следующей итерации.

Чем же является `acc` для первой итерации? В этом случае результат предыдущей итерации который можно было бы использовать отстутсвует. Поэтому `reduce()` используют первый элемент в коллекции как начальное значение и начинает обход со второго элемента.

Этот код считает как часто встречается слово 'Sam' в списке строк:
```javascript
const sentences = ['Mary read a story to Sam and Isla.',
                   'Isla cuddled Sam.',
                   'Sam chortled.'];

let count = 0;

for (let sentence of sentences) {
  count = count + (sentence.match(/Sam/g) || []).length;
}
```

Вот тот же код написанный с использованием reduce:
```javascript
const sentences = ['Mary read a story to Sam and Isla.',
                   'Isla cuddled Sam.',
                   'Sam chortled.'];

const count = sentences.reduce((acc, s) => acc + (s.match(/Sam/g) || []).length, 0);
```

Как этот код определил чем будет начальное значение для `acc`? Начальным значением числа `acc` не может быть первое предложение из массива. Поэтому я его явно устанавливил в `0` третьим параметром `reduce()`. Это позволяет использовать значение не совпадающего типа с элементами коллекции.

**Чем map и reduce лучше?**

Во первых, они короче.

Во вторых, важнейшие части итераций — коллекции, операции и возвращаемое значение всегда находятся на предсказуемых места для каждого map и reduce.

В третьих, код в цикле может влиять на переменные, объявленные ранее или код, который будет выполняться после. По соглашению map и reduce функциональны.

В четвертых, map и reduce — элементарные операции. Каждый раз когда программист читает цикл, он должен следовать за логикой построчно. Он может строить предположения о том как код работает на основе своего опыта. В то время как map и reduce — сами по себе одновременно являются строительными блоками которые могут быть скомбинированы в комплексный алгоритм и элементами, которые читатель может сразу же понять и абстрагироваться, не заостряя внимания на особенностях реализации обхода цикла.

В пятых, map и reduce имеют множество друзей которые предоставляют полезные, адаптированные версии их стандартного поведения. Например: filter, some, every и find.

- - - -
**Упражнение 2.** Попробуйте переписать код ниже используя map, reduce и filter. Filter — еще один метод массивов, который принимает функцию. Он возвращает коллекцию из элементов, для которых функция вернет `true`.
```javascript
const people = [{'name': 'Mary', 'height': 160},
                {'name': 'Isla', 'height': 80},
                {'name': 'Sam'}];

let heightTotal = 0;
let heightCount = 0;

for (person of people) {
  if ('height' in person) {
    heightTotal += person.height;
    heightCount += 1;
  }
}

if (heightCount) {
  const averageHeight = heightTotal / heightCount;

  console.log(averageHeight)
}

// 120
```
Сперва может показаться что задача невыполнима, однако попробуйте не думать об операциях над данными. Вместо этого, подумайте о состояниях, через которые проходят данные, от списка людей до среднего роста. Низбегайте соблазна объединить несколько трансформаций вместе. Помещайте каждую операцию на новой линии и назначайте результат переменным с описательными именами. Когда код заработает, избавьтесь от лишних сущностей сделав его короче.

Мое решение:
```javascript
const people = [{'name': 'Mary', 'height': 160},
                {'name': 'Isla', 'height': 80},
                {'name': 'Sam'}];

const heights = people
  .filter(x => 'height' in x)
  .map(x => x.height);

if (heights.length > 0) {
  const averageHeight = heights.reduce((acc, num) => acc + num, 0) / heights.length;
  console.log(averageHeight)
}
```

## Пишите декларативно, не императивно
Программа ниже выполняет гонку между тремя машинами. В каждый шаг выполнения каждая машина может проехать дальше или оставаться на месте. После каждого шага программа печатает путь, проделанный машинами.

Вывод получается примерно таким:

```
 -
 - -
 - -

 - -
 - -
 - - -

 - - -
 - -
 - - -

 - - - -
 - - -
 - - - -

 - - - -
 - - - -
 - - - - -
```

А вот и сама программа:
```javascript
let time = 5;
let carPositions = [1, 1, 1];

while (time) {
  time -= 1;

  console.log('');
  for (let i = 0; i < carPositions.length; i++) {
    // Двигаю машину
    if (Math.random() > 0.3) {
      carPositions[i] += 1;
    }

    // Печатаю машину
    console.log('-'.repeat(carPositions[i]));
   }
}

```
Код написан в императивном стиле. Функциональная версия была бы декларативной. Она бы описала что она делает, вместо того как она это делает.

## Используйте функции
Программа может быть написана более декларативно разбиением логических частей кода на функции.

```javascript
let time = 5;
let carPositions = [1, 1, 1];

function moveCars() {
  for (let i = 0; i < carPositions.length; i++) {
    if (Math.random() > 0.3) {
      carPositions[i] += 1;
    }
  }
}

function drawCar() {
  console.log('-'.repeat(carPositions[i]));
}

function runStepOfRace() {
  time -= 1;
  moveCars();
}

function draw() {
  console.log('');
  for (let carPosition of carPositions) {
    drawCar(carPosition);
  }
}

while (time) {
  runStepOfRace();
  draw();
}
```
Для понимания этой программы читателю достаточно прочитать основной цикл: "Если время еще есть, выполнится шаг для гонки и программа визуализирует текущее состояние." Если читателю понадобится углубиться в реализацию каждой функции, он может изучить код внутри них по отдельности.

Здесь не нужны комментарии, код описывает сам себя.

Разделение кода на функции — это отличный, не требующий минимум усилий путь создавать более читаемые программы. Эта техника использует функции, но она использует их как под-программы. Функции занимаются доставкой выполняемого кода. Код не функциональный относительно нашего *ориентира*. Функции в примере используют глобальное состояние, которое не приходит в виде аргументов. Они влияют на код вокруг них и изменяют внешние переменные, вместо того что бы возвращать значения. Что бы проверить что функци на самом деле делает, читателю нужно узичить каждую линию с особым вниманием. Если он встретится с упоминанием внешней переменной, ему придется найти ее происхождение. Ему так же придется проверить изменяется ли эта переменная другими функциями.

## Избавляйтесь от глобального состояния
Это функциональная версия автомобильных гонок:
```javascript
function moveCars(carPositions) {
  return carPositions.map(x => Math.random() > 0.3 ? x + 1 : x);
}

function outputCar(carPosition) {
  return '-'.repeat(carPosition);
}

function runStepOfRace(state) {
  return {
    time: state.time - 1,
    carPositions: moveCars(state.carPositions),
  };
}

function draw(state) {
  console.log('');
  console.log(state.carPositions.map(outputCar).join('\n'));
}

function race(state) {
  draw(state)
  if (state.time) {
    race(runStepOfRace(state))
  }
}

race({
  time: 5,
  carPositions: [1, 1, 1],
});
```

Этот код так же разделен на функции, но теперь уже в функциональном стиле. Вот три признака, по которым этот код можно назвать функциональным:
1. Больше нет общих глобальных переменных. `time` и `carPositions` передаются прямо в `race()`.
2. Функции принимают параметры.
3. Нет состояния, инициализированного вне функций. Все преобразованные данные возвращаются непосредственно из функций как результат их работы. `race()` рекурсивно вызывает саму себя с результатом выполнения `runStepOfRace()` в качестве параметра. Каждый шаг генерирует новое состояние, которое тут же передается на следующий шаг.

Вот пример с двумя функциями `zero()` и `one()`:
```javascript
function zero(s) {
  if (s[0] === '0') {
    return s.slice(1);
  }
}

function one(s) {
  if (s[0] === '1') {
    return s.slice(1);
  }
}
```

`zero()` принимает строку `s`. Если первый символ `0` — она возвращает остаток строки без первого символа. Иначе она вернет `undefined`, встроенный тип JavaScript который возвращается функциями, которые ничего не возвращают. `one()` делает то же самое, для случая если первый символ равен `1`.

Представьте себе функцию, допустим, `ruleSequence()`. Она принимает строку и список правил вида `zero()` и `one()`. Эта функция применяет первое правило к переданной строке. Если результат не равен `undefined` — к нему применяется второе правило. Если результат не равен `undefined` — к нему применяется третье правило. И так далее. Если какое либо правило возвращает `undefined` — `ruleSequence()` останавливается и возвращает `undefined`. Иначе она возвращает результат применения последнего правила.

Вот пример ввода и вывода такой функции
```javascript
console.log(ruleSequence('0101', [zero, one, zero]))
// 1

console.log(ruleSequence('0101', [zero, zero]))
// undefined
```

А вот императивная реализация `ruleSequence()`:
```javascript
function ruleSequence(s, rules) {
  for (let rule of rules) {
    s = rule(s);

    if (s === undefined) {
      break;
    }
  }

  return s;
}
```

**Упражнение 3.** Код выше использует цикл. Сделайте его более декларативным переписав на рекурсию.

Мое решение:
```javascript
function ruleSequence(s, rules) {
  if (s === undefined || rules.length === 0) {
    return s;
  }

  return ruleSequence(rules[0](s), rules.slice(1));
}
```

## Используйте конвейеры (пайплайны)
В предыдущей части я переписал императивные циклы на рекурсии с вызовом преобразующих функций. В этой части я перепишу еще один тип императивного цикла используя технику, называемую конвейeризацией.

Цикл ниже выполняет трансформации на словарях, содержащих имя, некорректную страну происхождения и активный статус музыкальных групп.
```javascript
const bands = [{ name: 'sunset rubdown', country: 'UK', active: false },
               { name: 'women', country: 'Germany', active: false },
               { name: 'a silver mt. zion', country: 'Spain', active: true }];

function formatBands(bands) {
  for (let band of bands) {
    band.country = 'Canada';
    band.name = band.name.replace('.', '');
    band.name = band.name[0].toUpperCase() + band.name.substring(1);
  }
}

formatBands(bands);

console.log(bands);
// [{ name: 'Sunset Rubdown', active: false, country: 'Canada' },
// { name: 'Women', active: false, country: 'Canada' },
// { name: 'A Silver Mt Zion', active: true, country: 'Canada' }]
```

Название функции из примера вызывает беспокойство. Слово "format" не содержит конкретики. При близком изучении кода беспокойство начинает оправдывать себя: три разного вида трансформаций происходит в одном цикле. Значением свойства `county`  становится `'Canada'`, из имени группы удаляется пунктуация, а так же первая буква имени преобразовывается в заглавную. Здесь сложно сказать для чего именно предназначен этот код и трудно убедиться в том что он делает именно то что должен. Так же его почти невозможно переиспользовать, сложно тестировать и выполнять параллельно.

Сравните пример выше с этим:
```javascript
console.log(pipelineEach(bands, [setCanadaAsCountry,
                                 stripPuctuationFromName,
                                 capitalizeNames]));
```

Это код понимать легче. Он создает впечатление что преобразующие функции действительно функциональны потому что они кажутся связанными в цепочку. Результат выполнения одной может быть передан на вход следющей. Если они функциональные — легко убедиться в том что они делают именно то, что указано в их имени. Так же их легко переиспользовать, легко тестировать и выполнять параллельно.

Обязанность функции `pipelineEach()` сводится к передаче каждой музыкальной группы, по одной, в преобразующую функцию, например `setCanadaAsCountry()`. После того как все преобразования выполнены ко всем группам, `pipelineEach()` собирает результат и передает его следующим преобразованиям.

Псмотрите на преобразующие функции:
```javascript
function assoc(obj, key, value) {
  return {
    ...obj,
    [key]: value,
  };
}

function setCanadaAsCountry(band) {
  return assoc(band, 'country', 'Canada');
}

function stripPuctuationFromName(band) {
  return assoc(band, 'name', band.name.replace('.', ''));
}

function capitalizeNames(band) {
  const name = band.name[0].toUpperCase() + band.name.substring(1);
  return assoc(band, 'name', name);
}
```

Каждая ассоциирует ключ объекта музыкальной группы с новым значением. Что бы не мутировать исходный объект его нужно скопировать, но мне бы не хотелось каждый раз писать создание нового объекта потому я вынес эту работу в функцию `assoc()` .

Кажется, все отлично. Оригинальная коллекция групп защищена от изменений. Но здесь возможны две потенциальные мутации в коде выше. В `stripPuctuationFromName()` новое имя  генериуется вызовом `replace()` на исходном. В `capitalizeNames()` так же вызывается `toUpperCase` и `substring()`. Если эти функции не функциональные то и `stripPuctuationFromName()` и `capitalizeNames()` тоже не могут быть функциональными.

К счастью, во всех случаях возвращается новая строка, без мутации исходной. Это потому что строки в JavaScript не "мутабельные".  Когда, например, `replace()` преобразовывает строку с именем музыкального коллектива, оригинальное название копируется и `replace()` вызывается на копии. Фуф.

Это разница между мутабельностью строк и объектов в JavaScript иллюстрирует привлекательность функциональных языков, таких как Clojure. Программисту никогда не приходится думать изменяет ли он данные. Этого просто не происходит.

- - - -

**Упражнение 4.** Попробуйте самостоятельно реализовать функцию `pipelineEach()`. Думайте об порядке операций. Группы передаются по одной за раз, к первой трансформирующей функции. Потом ко второй. К третьей. И так далее.

Мое решение:
```javascript
function pipelineEach(data, fns) {
  return fns.reduce((acc, fn) => acc.map(fn), data);
}
```

Все три трансформации привязаны к изменению определенного поля в переданных объектах. Но можно абстрагироваться от структуры входного объекта с помощью `call()`. Она принимает функцию, производящую трансформацию и ключ, к которому нужно применить изменения.

```javascript
const setCanadaAsCountry = call(x => 'Canada', 'country');
const stripPuctuationFromName = call(x => x.replace('.', ''), 'name');
const capitalizeNames = call(x =>
  x[0].toUpperCase() + x.substring(1), 'name');

console.log(pipelineEach(bands, [setCanadaAsCountry,
                                 stripPuctuationFromName,
                                 capitalizeNames]));
```

Или, можно пожертвовать читаемостью ради краткости:
```javascript
console.log(pipelineEach(bands, [
  call(x => 'Canada', 'country'),
  call(x => x.replace('.', ''), 'name'),
  call(x => x[0].toUpperCase() + x.substring(1), 'name')
]));
```

Вот код для `call()`:
```javascript
function assoc(obj, key, value) {
  return {
    ...obj,
    [key]: value,
  };
}

function call(fn, key) {
  const applyFn = (record) => assoc(record, key, fn(record[key]));

  return applyFn;
}
```

**Секундочку, сейчас я все объясню. Шаг за шагом.**

1. `call()` — это функция высшего порядка. Функции высшего порядка принимают функцию как параметр или возвращают функцию. Или, как `call()` делают и то, и другое.
2. `applyFn()` выглядет очень похоже на три уже упомянутые трансформирующие функции. Она принимает объект (группу), берет значение по переданному ключу `record[key]` и вызывает переданную `fn` на этом значении. После она назначает результат копии переданного объекта и возвращает его.
3. `call()` не выполняет никаких изменений, все сделает `applyFn()` когда будет вызвана. В примере выше, где вызывается `pipelineEach()` одна копия `applyFn()` установит поле переданной группы `country` в `'Canada'`. Другая копия отформатирует имя.
4. Когда копия `applyFn()`  запускается, `fn` и `key`  нет в области видимости. Они не являются аргументами `applyFn()` и не объявлены локально в ее теле. Но они все равно будут доступны. Когда функция определяется, она сохраняет ссылки на переменные, на которые она замыкается: те что определяются во внешней области видимости функции и используются во внутренней. Когда функция выполняется и ее код ссылается на переменную, JavaScript ищет переменную в локальной области видимости и в аргументах. Если ничего подходящего не было найдено, тогда он ищет в сохраненных ссылках в замыкании. Вот где  `fn` и `key`  могут быть найдены.
5. Я не упоминал объекты музыкальных группы в коде `call()`. Это потому что `call()` может быть использована для генерации пайплайнов в любой программе, не зависимо от предметной области. Функциональные программирование частично связано с созданием библиотеки общих, переиспользуемых и пригодных к композиции функций.

Отличная работа. Замыкания, функции высшего порядка и области видимости переменных были разобраны всего в паре параграфов. Теперь можно и расслабиться.

- - - -

Осталось рассмотреть еще один способ обработки групп, который очищает объект группы от лишних полей, отравляя только название и страну происхождения. `extractNameAndCountry()` поможет вытащить эту информацию.

```javascript
function extractNameAndCountry(band) {
  return {
    name: band.name,
    country: band.country,
  };
}

console.log(pipelineEach(bands, [call(x => 'Canada', 'country'),
  call(x => x.replace('.', ''), 'name'),
  call(x => x[0].toUpperCase() + x.substring(1), 'name'),
  extractNameAndCountry,
]));

// [{ country: "Canada", name: "Sunset rubdown" },
//  { country: "Canada", name: "Women" },
//  { country: "Canada", name: "A silver mt zion" }]
```
`extractNameAndCountry()` можно переписать как общую функцию  `pluck()`.

Вот как это будет выглядеть:
```javascript
console.log(pipelineEach(bands, [
  call(x => 'Canada', 'country'),
  call(x => x.replace('.', ''), 'name'),
  call(x => x[0].toUpperCase() + x.substring(1), 'name'),
  pluck(['name', 'country']),
]));
```

**Упражнение 5.** `pluck()` принимает список ключей каждого объекта. Попробуйте реализовать ее. Она должны быть функцией высшего порядка.

Мое решение:
```javascript
function pluck(keys) {
  return (record) => keys.reduce((acc, key) => assoc(acc, key, record[key), {});
}
```

## Что дальше?
Функциональный код отлично со-существует и сочетается с кодом, написанном в других стилях. Трансформации, упомянутые в этой статье могут быть применены к любой кодовой базе на любом языке. Попробуйте использовать их в своем коде.

Вспомните о Мэри, Эйле и Сэму. Превратите итерации над списками в map и reduce.

Вспомните о гонке. Разбейте код на функции. Сделайте их функциональными. Попробуйте переписать цикл на рекурсию.

Вспомните о музыкальных группах. Оберните последовательность операций в пайплайн.

- - -

<section class="notes">

1. <span id="note:1">Иммутабельные данные — это данные которые никогда не изменяются. В некоторые языках, вроде Clojure, все значение иммутабельные по умолчанию. Любая "мутирующая" операция копирует исходное значение, меняет его и возвращает измененную копию. Это позволяет избежать ошибок, возникающих при неполном понимании программистом состояний, в которые может входить программа.<a href="#ref:1" class="back-to-ref">↑</a></span>
2. <span id="note:2">Некоторые языки позовляют пользоваться фукнциями как объектами первого класса. Такие функции могут создаваться динамически, быть переданными в качестве параметров другим функциям, возвращаться в качестве результата выполнения функци, а так же храниться в структурах данных.<a href="#ref:2" class="back-to-ref">↑</a></span>
3. <span id="note:3">Хвостовые оптимизации — это особенность языка программирования. Каждый раз, когда функция рекусривно вызывает саму себя создается новый фрейм в стэке вызовов. Фрейм хранит в себе аргументы и локальные переменные для текущего вызова функции. Если рекурсия выполняется достаточно большое количество раз у компилятора или интерпретатора есть веротяность выйти за пределы памяти. Языки с реализованной хвостовой оптимизацией преиспользуют один и тот же фрейм для каждого вызова рекурсивной функции. Языки, вроде JavaScript или Python не имеют такой оптимизации и их лимит для таких вызовов ограничивается десятком тысяч. В случае с нашим примером `race()` создает рекурсию лишь из пяти вызовов, так что тут мы в безопасности.<a href="#ref:3" class="back-to-ref">↑</a></span>
4. <span id="note:4">Каррирование применяется для декомпозиции функции, которая принимает множество аргументов в функцию которая принимает один аргумент и возвращает новую функцию, которая принимает второй аргумент и так далее для всех аргументов.<a href="#ref:4" class="back-to-ref">↑</a></span>
5. <span id="note:5">Параллелизация подразумевает выполнение кода параллельно без синхронизации. Эти параллельные операции часто выполняются одновременно на нескольких процессорах.<a href="#ref:5" class="back-to-ref">↑</a></span>
6. <span id="note:6">Ленивые вычисления — это техника компиляции которая избегает выполнения код до тех пор, пока не понадобится результат, который он вычисляет.<a href="#ref:6" class="back-to-ref">↑</a></span>
7. <span id="note:7">Процесс детерминирован если результат его работы каждый раз дает один и тот же результат.<a href="#ref:7" class="back-to-ref">↑</a></span>

</section>